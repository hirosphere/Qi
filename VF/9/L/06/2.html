<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
<title>PW 整数倍</title>
<link rel="stylesheet" href="Common.css"/>
<style>

.Pad
{
	padding: 50px;
	text-align: center;
}

.Button
{
	display: inline-block;
	margin: 0 40px;
	width: 100px; height: 100px;
	border: 1px solid hsl( 0, 0%, 30% );
}

</style>
</head>

<body onload="const アプリケーション = new アプリケーション型()">

<script>

const アプリケーション型 = function()
{
	const この実体 = this;

	この実体.初期化 = function()
	{
		const 音響文脈 = new AudioContext();
		const 残響器 = new 残響1型( 音響文脈, 音響文脈.destination );
		const 音源1 = new 音源1型( 音響文脈, 残響器.入力, 64, 4, 1 / 20 );
		const 音源2 = new 音源1型( 音響文脈, 残響器.入力, 69, 4, 1 / 24 );
		{
			const 主エレメント = エレメントを作成( "div", document.body, { クラス: "Pad" } );
			new 発車ベル版型( 主エレメント, 音源1 );
			new 発車ベル版型( 主エレメント, 音源2 );
		}
	};

	この実体.初期化();
};

const 発車ベル版型 = function( 幹エレメント, 音源 )
{
	const この実体 = this;

	この実体.初期化 = function()
	{
		const ボタン = ボタンを作成( "鳴動", 幹エレメント, 音源 );
	};

	function ボタンを作成( ラベル, 幹エレメント, 音源 )
	{
		const ボタン = エレメントを作成( "span", 幹エレメント, { 文: "鳴動", クラス: "Button" } );
		let 動作中 = いいえ;

		ボタン.addEventListener
		(
			"touchstart",
			( ev ) =>
			{
				if( ! 動作中 ){
					動作中 = はい;
					if( ev.cancelable ){
						ev.preventDefault();
					}
					else console.log( "キャンセル不可" );
					音源.指令を投函( { 種類: "打鍵" } );
				}
			}
		);

		ボタン.addEventListener
		(
			"touchcancel",
			( ev ) =>
			{
				console.log( "touchcancel" );
				if( 動作中 )
				{
					動作中 = いいえ;
					音源.指令を投函( { 種類: "離健" } );
				}
			}
		);

		ボタン.addEventListener
		(
			"touchend",
			( ev ) =>
			{
				if( 動作中 )
				{
					動作中 = いいえ;
					音源.指令を投函( { 種類: "離健" } );
				}
			}
		);

		ボタン.addEventListener
		(
			"mousedown",
			( ev ) =>
			{
				console.log( "mousedown" );

				if( ! 動作中 )
				{
					動作中 = はい;
					音源.指令を投函( { 種類: "打鍵" } );
				}
			}
		);

		ボタン.addEventListener
		(
			"mouseup",
			( ev ) =>
			{
				console.log( "mouseup" );
				
				if( 動作中 )
				{
					動作中 = いいえ;
					音源.指令を投函( { 種類: "離健" } );
				}
			}
		);

		return ボタン;
	}

	この実体.初期化();
};

// 音響 //

const 音源1型 = function( 音響文脈, 送り先, 基本音程, 変調幅, 変調速度 )
{
	const この実体 = this;

	この実体.初期化 = function( 音響文脈 )
	{
		この実体.音響文脈 = 音響文脈;

		// ノード生成 //

		この実体.音声発振 = この実体.音響文脈.createOscillator();
		この実体.音声制幅 = この実体.音響文脈.createGain();

		この実体.変調発振 = この実体.音響文脈.createOscillator();
		この実体.変調制幅 = この実体.音響文脈.createGain();

		この実体.変形器 = この実体.音響文脈.createScriptProcessor( 0, 2, 1 );

		// 値の設定 //

		この実体.音声発振.frequency.value = 55;
		この実体.音声発振.detune.value = ( ( 基本音程 - 69 ) * 100 );
		この実体.音声発振.type = "sawtooth";
		この実体.音声制幅.gain.value = 0.0;
		
		この実体.変調発振.frequency.value = 変調速度;
		この実体.変調発振.type = "triangle";
		この実体.変調制幅.gain.value = 変調幅;

		この実体.変形器.onaudioprocess = ( ev ) =>
		{
			const carr = ev.inputBuffer.getChannelData( 0 );
			const mod = ev.inputBuffer.getChannelData( 1 );
			const output = ev.outputBuffer.getChannelData( 0 );
			
			for( let i = 0; i < output.length; i ++ )
			{
				const ph = ( ( carr[ i ] * mod[ i ] ) % 1 + 1 ) / 2;
				output[ i ] = Math.sin( ph * Math.PI );
			}
		};
		
		
		// 接続 //

		この実体.音声発振.connect( この実体.変形器 );
		//この実体.音声発振.connect( この実体.音声制幅 );
		この実体.変形器.connect( この実体.音声制幅 );
		この実体.音声制幅.connect( 送り先 );

		この実体.変調発振.connect( この実体.変調制幅 );
		この実体.変調制幅.connect( この実体.変形器 );

		//  //

		この実体.音声発振.start();
		この実体.変調発振.start();
	};

	この実体.指令を投函 = function( 指令 )
	{
		switch( 指令.種類 )
		{
			case "打鍵":  この実体.打鍵( 指令 );  break;
			case "離健":  この実体.離健( 指令 );  break;
		}
	};

	この実体.打鍵 = function( 指令 )
	{
		if( この実体.音響文脈.state == "suspended" )
		{
			この実体.音響文脈.resume();
		}

		const 音量 = 0.14;
		const 開始時刻 = この実体.音響文脈.currentTime + 0.001;
		この実体.音声制幅.gain.setTargetAtTime( 音量 / 0.63, 開始時刻, 0.001 );
	};

	この実体.離健 = function( 指令 )
	{
		const 開始時刻 = この実体.音響文脈.currentTime + 0.001;
		この実体.音声制幅.gain.setTargetAtTime( 0, 開始時刻, 0.001 );
	};

	この実体.初期化( 音響文脈 );
};

const 残響1型 = function( 音響文脈, 送り先 )
{
	const この実体 = this;	
	const 入力制幅 = 音響文脈.createGain();
	const 濾過器1 = 音響文脈.createBiquadFilter();
	const 遅延器1 = 音響文脈.createDelay();
	const 帰還制幅11 = 音響文脈.createGain();
	const 帰還制幅12 = 音響文脈.createGain();
	const 遅延器2 = 音響文脈.createDelay();
	const 帰還制幅21 = 音響文脈.createGain();
	const 帰還制幅22 = 音響文脈.createGain();
	const 混合器 = 音響文脈.createChannelMerger();
	const 残響制幅 = 音響文脈.createGain();
	const 原音制幅 = 音響文脈.createGain();
	const 出力制幅 = 音響文脈.createGain();
	
	濾過器1.type = "bandpass";
	濾過器1.frequency.value = 6300;
	濾過器1.Q.value = 0.7;
	遅延器1.delayTime.value = 0.107;
	遅延器2.delayTime.value = 0.157;
	原音制幅.gain.value = 1.0;
	残響制幅.gain.value = 0.20;
	帰還制幅11.gain.value = 0.10;
	帰還制幅12.gain.value = 0.20;
	帰還制幅22.gain.value = 0.10;
	帰還制幅21.gain.value = 0.20;

	入力制幅.connect( 原音制幅 );
	入力制幅.connect( 濾過器1 );
	濾過器1.connect( 遅延器1 );
	濾過器1.connect( 遅延器2 );

	遅延器1.connect( 帰還制幅11 );
	遅延器1.connect( 帰還制幅12 );
	遅延器1.connect( 混合器, 0, 0 );
	帰還制幅11.connect( 遅延器1 );
	帰還制幅12.connect( 遅延器2 );

	遅延器2.connect( 帰還制幅21 );
	遅延器2.connect( 帰還制幅22 );
	遅延器2.connect( 混合器, 0, 1 );
	帰還制幅22.connect( 遅延器2 );
	帰還制幅21.connect( 遅延器1 );
	
	混合器.connect( 残響制幅 );
	残響制幅.connect( 出力制幅 );
	原音制幅.connect( 出力制幅 );
	出力制幅.connect( 送り先 );

	この実体.入力 = 入力制幅;
};

// 汎用 //

const はい = true;
const いいえ = false;
const 虚 = undefined;
const 無 = null;

function エレメントを作成( 型名, 幹エレメント, 設定 )
{
	const エレメント = document.createElement( 型名 );
	if( 設定 )
	{
		if( 設定.クラス != null ) エレメント.className = 設定.クラス;
		if( 設定.文 != null ) エレメント.innerHTML = 設定.文;
	}
	if( 幹エレメント ) 幹エレメント.appendChild( エレメント );
	return エレメント;
};

</script>
</body>
</html>