<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
<title>VF902</title>
<script src="../../Base/Prime.js"></script>
<script src="./Common/Common.js"></script>
<style>
*
{
	margin: 0; padding: 0;
	font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

html
{
	background: hsl( 210, 60%, 90% );
	padding: 50px;
}

body
{
	margin: 0px auto;
	width: 720px;
	padding: 40px 40px;
	border-radius: 16px;
	min-height: 90vh;
	background: #fff;
}

.PAD1
{
	pointer-events: ;
	border: 3px solid hsl( 30, 6%, 60% );
	background: hsl( 180, 70%, 96% );
	border-radius: 11px;
	width: 280px; height: 280px; margin-bottom: 30px;
}

.INPUT_TABLE { border: 1px solid #999; padding: 12px; }
.INPUT_TABLE .CAP { font-size: 13px; }
.INPUT_TABLE .INPUT { margin: 0 0.2ex 0 1ex; width: 110px; height: 34px; font-size: 18px; }
.INPUT_TABLE .UNIT { font-size: 14px; }
.INPUT_TABLE .RANGE { margin: 0 1ex; width: 400px; padding: 6px }

</style>
</head>
<body onload="Main.Initiate();">
<script>

let Main = new function()
{
	this.Initiate = function()
	{
		new App();
	};
};

// UI //

let App = class_def
(
	null,
	function()
	{
		this.Initiate = function()
		{
			this.Doc = new Document();
			this.e = q.div( document.body, { "class": "APP" } );
			new ControlPane( this.e, this.Doc );
		};
	}
);

let LogMeasure = class_def
(
	Measure,
	function()
	{
		this.BaseFreq = 1;
		this.OctStep = 120;

		this.VtoM = function( value )
		{
			return ( Math.log( value ) / Math.LN2 ) * this.OctStep;
		};

		this.MtoV = function( measure )
		{
			return Math.pow( 2, measure / this.OctStep );
		};
	}
);

let ControlPane = function( com, doc )
{
	let e = q.col( com );
	{
		let meas1 = new Measure( { RStep: 0.1 } );
		let meas2 = new LogMeasure( { RMax: 120 * 14, RStep: 1 } );
		let pw_meas = new Measure( { RMax: 100, RStep: 0.1 } );

		let pitems = [];
		pitems[ 0 ] =
		{
			Size: 100, Label: "300Hz", Color: "",
			Type: "PW", Freq: 300
		};

		new SensePad( e, { Class: "PAD1", Width: 280, Height: 280, OnChange: onsense } );
		let m = q.div( e, { style: { height: "1.3em" } } );

		function onsense( type, x, y )
		{
			let freq = [ 150, 300, 600, 900 ][ Math.floor( y * 4 ) ] || 0;
			let pw = x * 100;
			q.text( m, `${ type } ${ freq } ${ pw }` );
			doc.Synth.PulseGen.Freq.Set( freq );
			doc.Synth.PulseGen.Width.Set( pw );
			doc.Synth.PulseGen.Gate.Set( type != "end" );
		}

		let table = q.table( e, { "class": "INPUT_TABLE" } );
		let col = q.tbody( table, {} );

		CreateInput( col, "音量", "%", doc.Synth.Volume, meas1 );
		CreateInput( col, "Sin音量", "%", doc.Synth.SinLevel, meas1 );
		CreateInput( col, "Sin1周波数", "Hz", doc.Synth.Freq, meas2 );
		CreateInput( col, "Sin2周波数差", "Hz", doc.Synth.DeFreq, meas2 );
		CreateInput( col, "ノイズ音量", "%", doc.Synth.NoiseLevel );
		CreateInput( col, "パルス音量", "%", doc.Synth.PulseGen.Level );
		CreateInput( col, "パルス周波数", "Hz", doc.Synth.PulseGen.Freq, meas2 );
		CreateInput( col, "パルス幅", "%", doc.Synth.PulseGen.Width, pw_meas );
	}
};

let SensePad = class_def
(
	null,
	function()
	{
		this.Initiate = function( com, args )
		{
			this.Point = { x: 0, y: 0 };
			this.Canvas = q.e( "canvas", com, { "class": args.Class } );
			this.Canvas.width = args.Width;
			this.Canvas.height = args.Height;
			let self = this;
			let def = function( ev ) { ev.preventDefault(); };
			this.Canvas.ontouchstart = function( ev ){ self.OnTouch( "start", ev ); };
			this.Canvas.ontouchmove = function( ev ){ self.OnTouch( "move", ev ); };
			this.Canvas.ontouchend = function( ev ){ self.OnTouch( "end", ev ); };
			this.OnChange = args.OnChange;
			this.InitGraph();
		};

		this.InitGraph = function()
		{
			let context = this.Canvas.getContext( "2d" );
			context.fillStyle = "hsl( 33, 4%, 90% )";
			context.fillRect( 0, 0, this.Canvas.width, this.Canvas.height );
			this.Update();
		};

		this.OnTouch = function( type, ev )
		{
			let x = ev.changedTouches[ 0 ].pageX - this.Canvas.offsetLeft;
			let y = ev.changedTouches[ 0 ].pageY - this.Canvas.offsetTop;
			let w = this.Canvas.offsetWidth;
			let h = this.Canvas.offsetHeight;
			let item = null;
			this.OnChange && this.OnChange( type, x / w, 1 - ( y / h ), item );
			ev.preventDefault();
		};

		this.Update = function()
		{
			let context = this.Canvas.getContext( "2d" );
		};

	}
);

function CreateInput( com, label, unit, value, measure )
{
	let row = q.tr( com, {} );
	q.label( q.td( row ), { text: label, "class": "CAP" } );
	new Input( q.td( row ), value, { "class": "INPUT" } );
	q.label( q.td( row ), { text: unit, "class": "UNIT" } );
	new Slider( q.td( row ), value, { "class": "RANGE" }, measure );
}

// Doc //

let Document = class_def
(
	null,
	function()
	{
		this.Initiate = function()
		{
			this.Synth = new Synth();
		};
	}
);

// Audio //

let Synth = class_def
(
	null,
	function()
	{
		this.Initiate = function()
		{
			this.Change = new Value( false );
			this.Volume = new Value( 10, onchange );
			this.SinLevel = new Value( 0, onchange );
			this.Freq = new Value( 200, onchange );
			this.DeFreq = new Value( 1, onchange );
			this.NoiseLevel = new Value( 0, onchange );
			this.PulseGen =
			{
				Level: new Value( 30, onchange ),
				Gate: new Value( false, onchange ),
				Freq: new Value( 600, onchange ),
				Width: new Value( 28.5, onchange )
			};

			this.Impl = new SynthImpl( this );

			let self = this;
			function onchange()
			{
				self.Change.Set( true, true );
			}
		};
	}
);

let SynthImpl = class_def
(
	null,
	function()
	{
		this.Initiate = function( model )
		{
			this.Model = model;

			let self = this;
			this.Context = new AudioContext();

			this.Osc1 = this.Context.createOscillator();
			this.Osc2 = this.Context.createOscillator();
			this.Proc = this.Context.createScriptProcessor();
			this.OscGain = this.Context.createGain();
			this.Volume = this.Context.createGain();

			this.Proc.onaudioprocess = ( ev ) => self.OnProc( ev );

			this.Osc1.connect( this.OscGain );
			this.Osc2.connect( this.OscGain );
			this.OscGain.connect( this.Volume );
			this.Proc.connect( this.Volume );
			this.Volume.connect( this.Context.destination );

			this.POsc = new POsc( this.Model.PulseGen, this.Context );

			this.Osc1.start();
			this.Osc2.start();

			this.Model.Change.AddClient( ()=>self.Update() );
		};

		this.OnProc = function( ev )
		{
			let ch1 = ev.outputBuffer.getChannelData( 0 );
			let ch2 = ev.outputBuffer.getChannelData( 1 );
			let nlevel = this.Model.NoiseLevel.Value / 100 * 2;
			let plevel = this.Model.PulseGen.Level.Value / 100;
			
			this.POsc.OnProc();

			for( let i = 0; i < ch1.length; i ++ )
			{
				let sample =
					( Math.random() - 0.5 ) * nlevel
					+ this.POsc.Step() * plevel
				;

				ch1[ i ] = ch2[ i ] = sample;
			}
		};

		this.Update = function()
		{
			this.Osc1.frequency.value = this.Model.Freq.Value;
			this.Osc2.frequency.value = this.Model.Freq.Value + this.Model.DeFreq.Value;
			this.OscGain.gain.value = this.Model.SinLevel.Value / 100;
			this.Volume.gain.value = this.Model.Volume.Value / 100;
		};

	}
);

function POsc( model, context )
{
	var phase = 0;
	var gate;
	var rate;
	var width;
	var smr;

	var _rate = 0;
	var _width = 0;

	let osr = 4;

	this.OnProc = function()
	{
		gate = model.Gate.Value;
		width = model.Width.Value / 100;
		rate = model.Freq.Value / ( context.sampleRate * osr );
		smr = 10000 / context.sampleRate;
	};

	this.Step = function()
	{
		_rate += ( rate - _rate ) * smr;
		_width += ( width - _width ) * smr;

		var acc = 0;
		for( let i = 0; i < osr; i ++ )
		{
			let sample = ( phase >= _width ? 1 : -1 );
			phase += _rate;
			if( phase >= 1 ) phase -= 1;
			acc += sample;
		}
		return gate ? acc / osr : 0;
	};
}

//  //

//  //

//  //

//  //


</script>
</body>
</html>