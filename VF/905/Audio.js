//  //

const シーケンサの型 = function( 文脈, 複楽器 )
{
	let 時刻 = 0;	//  秒
	let ブロック時間 = 1;
	let 余裕時間 = 0.03;

	this.開始 = function()
	{
		;
	};
	
	this.停止 = function()
	{
		;
	};
	
	this.一時停止 = function()
	{
		;
	};
};

const 複楽器の型 = function( 文脈, 出力先, 楽器群 )
{
	this.出力 = 文脈.ゲインを作成();
	this.出力.振幅().値( 0 );
	this.出力.接続( 出力先 );

	this.前出力 = 文脈.ゲインを作成();
	this.前出力.振幅().値( 1 );
	this.前出力.接続( this.出力 );

	//音量テーブルを作成( 文脈, 4, 4, 1 );

	//文脈.音量等比テーブル = 文脈.等比テーブルを作成(  );

	for( let i in 楽器群 )  楽器群[ i ].出力.接続( this.前出力 );

	this.予定を投函 = function( 予定 )
	{
		const 楽器 = 楽器群[ 予定.チャンネル ];
		if( 楽器 )
		{
			楽器.予定を投函( 予定 );
		}
	};

	this.音量を設定 = function( 値 )
	{
		this.出力.振幅().その時刻へ直線変化( 値 / 100, 文脈.現在時刻() + 0.01 );
		//this.出力.振幅().値( this.音量 );
	};

	this.音量テーブルテスト = function() { return 音量テーブルを作成( 文脈, 10, 16 ) }

	function 音量テーブルを作成( 文脈, o, d )
	{
		const テーブル = new Float32Array( o * d * 2 + 3 );
		let index = 0;
		const スケール = Math.pow( 2, o );

		for( let i = 0, ct = o * d + 2; i < ct; i ++ )  テーブル[ index ++ ] = 0;

		for( let oi = 0; oi < o; oi ++ )
		{
			for( let di = 0; di < d; di ++ )
			{
				const v = Math.pow( 2, oi + di / d ) / スケール;
				テーブル[ index ++ ] = v;
			}
		}

		テーブル[ index ++ ] = 1;

		文脈.音量曲線 = テーブル;

		return Array.from( テーブル ).join( "\n" );
	}
}

const 単楽器の型 = function( 文脈, 声数, モデル )
{
	const 声群 = [];
	const 出力 = this.出力 = 文脈.ゲインを作成();

	let 次の声番 = 0;
	
	//
	this.予定を投函 = function( 予定 )
	{
		文脈.状態() == "suspended" && 文脈.再開();
		switch( 予定.種類 )
		{
			case "打鍵":
			{	
				if( 声群[ 予定.キー ] )
				{
					声群[ 予定.キー ].離健( 予定 );
				}

				const 単声 = 声群[ 予定.キー ] = new 単声の型( 文脈, 出力, モデル );
				単声.打鍵( 予定 );

				break;
			}

			case "離鍵":
			{
				const 単声 = 声群[ 予定.キー ];
				単声 && 単声.離鍵( 予定 );
				delete 声群[ 予定.キー ];
				break;
			}
		}
	};

	this.保存値を設定 = function( 値 )
	{
	};

	this.保存値を取得 = function()
	{
		;
	};

	let t = 文脈.現在時刻();

};

const 単声の型 = function( 文脈, 出力先, モデル )
{
	const Mo = モデル.要素;
	const EG = モデル.要素.EG1.要素;

	const オシレーター1 = 文脈.オシレーターを作成();
	const エンベロープゲイン = 文脈.値ゲインを作成( 0 );
	const 音量入力 = 文脈.波形変形器を作成();
	const 出力ゲイン = 文脈.ゲインを作成();
	const 出力 = 出力ゲイン;

	const 波形名 = { "sin": "sine", "saw": "sawtooth", "squ": "square" };

	オシレーター1.周波数().値( 440 );
	オシレーター1.波形( 波形名[ Mo.波形.値().toLowerCase() ] || "sine" );
	音量入力.curve = new Float32Array( [ 0,0,0,0,0,0,0,0, 0, 0.008, 0.016, 0.03125, 0.0625, 0.125, 0.25, 0.5, 1 ] );
	音量入力.curve = 文脈.音量曲線;
	出力ゲイン.振幅().値( 0 );

	オシレーター1.接続( 出力ゲイン );

	エンベロープゲイン.接続( 音量入力 );
	音量入力.接続( 出力ゲイン.振幅() );
	出力ゲイン.接続( 出力先 );
	
	オシレーター1.開始();

	this.打鍵 = function( 予定 )
	{
		const t = 文脈.現在時刻() + 0;
		オシレーター1.ピッチ().その時刻の値( ( 予定.キー - 69 + Mo.移調.値() ) * 100, t );

		
		const a = t + EG.A.値() / 1000;
		const d = a + EG.D.値() / 1000;
		
		エンベロープゲイン.振幅().その時刻の値( 0, t );
		エンベロープゲイン.振幅().その時刻へ直線変化( 1, a );
		エンベロープゲイン.振幅().その時刻へ直線変化( EG.S.値() / 100, d );
	};

	this.離鍵 = function( 予定 )
	{
		const t = 文脈.現在時刻() + 0;
		const r = t + EG.R.値() / 1000;
		
		エンベロープゲイン.振幅().予定を破棄( t );
		エンベロープゲイン.振幅().その時刻へ直線変化( 0, r );
		オシレーター1.終了( r );

		時限を設定( 後始末, EG.R.値() );
	};

	function 後始末()
	{
		出力.切断( 出力先 );
	}
};

