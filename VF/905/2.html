<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
<title>VF905-2</title>
<style>
*
{
	margin: 0; padding: 0; color: #222;
	font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

html
{
	background: hsl( 210, 80%, 90% );
	padding: 0px 40px;
}

body
{
	min-height: 200vh;
	background: hsl( 210, 0%, 100% );
	padding: 30px 40px;
}

.DIV1 { padding: 0px; }
.SEP { height: 10px; }
.VBOX { padding: 9px 0; }
.VLB { vertical-align: middle; }
input[type="range"] { vertical-align: middle; }

button { margin-bottom: 10px; padding: 16px 24px; border-radius: 6px; }

#dummy { color: #fff; }

</style>
</head>
<body onload="window.main = new Main();">

<div class="DIV1">
	<button onclick='main.起動( "u1", [], "vvvf", [ "test1", 1050 ] )'>VVVF 1050</button>
	<button onclick='main.起動( "u1", [], "vvvf", [ "test1", 600 ] )'>VVVF 600</button>
	<button onclick='main.起動( "u1", [], "pwm", [ "t3", 300 ] )'>営団 03</button>
	<button onclick='main.起動( "u1", [], "pwm", [ "t1", 330 ] )'>営団 7000</button>
	<button onclick='main.起動( "u1", [], "pwm", [ "t1", 300 ] )'>国鉄201系</button>
	<button onclick='main.起動( "u1", [], "pwm", [ "t2", 300 ] )'>国鉄201系 2</button>
	<button onclick="main.起動( 'u1', [], 'aph', [ 1, 50 ] )">交流位相50Hz</button>
	<button onclick="main.起動( 'u1', [], 'aph', [ 1, 60 ] )">交流位相60Hz</button>
	<button onclick="main.起動( 'u1', [], 'aph', [ 1, 440 ] )">交流位相440Hz</button>
	<button onclick="main.運転装置.停止()">停止</button>


<div class="SEP"></div>

	<canvas id="analyser" width="600" height="240" style= "border: 2px solid hsl( 57, 2%, 70% ); width: 600px; height: 240px;"></canvas>
	
	<div class="VBOX">
		<span class="VLB">音量</span> <input type="range" id="volume" value="30"; style="width: 300px;"/>
	</div>
</div>

<p id="dummy"></p>

<script>

const Main = function()
{
	const 文脈 = new AudioContext();

	const 音質フィルタ = 文脈.createBiquadFilter( { frequency: 2000, Q: 0.0 } );
	//音質フィルタ.connect( 文脈.destination );

	const 音量ノード = 文脈.createGain();
	{
		音量ノード.connect( 文脈.destination );
		const 音量レンジ = document.getElementById( "volume" );
		const 音量更新 = ()=> 音量ノード.gain.value = 音量レンジ.value / 100;
		音量レンジ.onchange = 音量更新;
		音量更新();
	}

	const 入力ノード = 文脈.createGain();
	{
		入力ノード.connect( 音量ノード );
		入力ノード.gain.value = 1;
	}

	const 運転装置 = this.運転装置 = new 運転装置の型( 文脈 );
	const 波形グラフ = new グラフの型( document.getElementById( "analyser" ), 文脈.sampleRate, 50 );
	const 電力音源 = new 電力音源の型( 文脈, 運転装置, 入力ノード, 波形グラフ );

	const dummy_el = document.getElementById( "dummy" );
	let dummy_ctr = 0;
	setInterval( ()=>{ dummy_el.textContent = ( new Date().getMilliseconds() ); }, 1000 / 15 );

	this.起動 = function( 運転パターン名, 運転パラメータ, 動力種名, 動力パラメータ )
	{
		運転装置.起動( 運転パターン名, 運転パラメータ );
		電力音源.種類を設定( 動力種名, 動力パラメータ );
	};
};


// github.io 対策

const 運転装置の型 = function( 文脈 )
{
	const モーター電力 = this.電力ノード = 文脈.createConstantSource();
	モーター電力.offset.value = 0;
	モーター電力.start();

	this.起動 = function( 運転パターン名, パラメータ )
	{
		文脈.resume();
		let cur = 文脈.currentTime;

		モーター電力.offset.cancelScheduledValues( cur );
		モーター電力.offset.setValueAtTime( 0, cur  );
		モーター電力.offset.linearRampToValueAtTime( 1, cur += 45  );
		モーター電力.offset.linearRampToValueAtTime( 1, cur += 6  );
		モーター電力.offset.linearRampToValueAtTime( 0, cur += 25  );
	};

	this.停止 = function()
	{
		let cur = 文脈.currentTime;

		モーター電力.offset.cancelScheduledValues( cur );
		モーター電力.offset.linearRampToValueAtTime( 0, cur += 0.20  );
	};

};

const 電力音源の型 = function( 文脈, 運転装置, 出力先ノード, 波形グラフ )
{
	let 音源子 = null;
	const 音源子群 = {};

	this.モニター同期;

	this.種類を設定 = function( 名称, パラメータ )
	{
		let temp = 音源子群[ 名称 ];
		if( temp == null )
		{
			const 型 = 電力音源子の型群[ 名称 ];
			if( 型 ) temp = 音源子群[ 名称 ] = new 型( 文脈 );
			else temp = 音源子群[ "def" ] = 音源子群[ "def" ] || new 電力音源子の型群.def( 文脈 );
		}
		
		if( 音源子 ) 音源子.切断();
		音源子 = temp;
		音源子.接続( 運転装置, 出力先ノード, パラメータ, 波形グラフ );
	};
};

const 電力音源子の型群 = new function()
{
	// 基底型 //

	const 基底の型 = function( 文脈 )
	{
		const プロセッサ = 文脈.createScriptProcessor( 0, 1, 1 );
		let 制御器;

		プロセッサ.onaudioprocess = ( ev ) => this.波形生成
		(
			ev.outputBuffer.getChannelData( 0 ),
			ev.inputBuffer.getChannelData( 0 ),
			文脈.sampleRate
		);
		
		this.接続 = function( _制御器, 出力ノード, パラメータ, 波形グラフ )
		{
			制御器 = _制御器;
			this.パラメータ = パラメータ;
			this.波形グラフ = 波形グラフ;

			プロセッサ.connect( 出力ノード );
			制御器.電力ノード.connect( プロセッサ );

			this.設定変更処理( this.パラメータ );
		};

		this.設定変更処理 = function( パラメータ )
		{
		};
		
		this.切断 = function()
		{
			プロセッサ.disconnect();
			制御器 && 制御器.電力ノード.disconnect( プロセッサ );
			制御器 = null;
			this.波形グラフ = null;
		};
		
	};
	
	// 直流PWM //

	const PWM基底の型 =
	this.def =
	this.pwm = function( 文脈 )
	{
		let キャリア位相 = 0;
		let モニター位相 = 0;
		let キャリア周波数テーブル = [ [ 0, 300 ] ];
		
		基底の型.call( this, 文脈 );

		this.設定変更処理 = function( パラメータ )
		{
			キャリア周波数テーブル = [ [ 0, 300 ] ];
			const 倍率テーブル = PWM周波数倍率テーブル[ パラメータ[ 0 ] ];
			const 基本周波数 = パラメータ[ 1 ] || 150;

			if( 倍率テーブル ) for( let i in 倍率テーブル )
			{
				const 項目 = 倍率テーブル[ i ];
				キャリア周波数テーブル[ i ] = [ 項目[ 0 ], 項目[ 1 ] * 基本周波数 ];
			}
		};

		this.波形生成 = function( 出力, 電力入力, サンプリング周波数 )
		{
			for( let i = 0; i < 出力.length; i ++ )
			{
				const 電力 = 電力入力[ i ];
				const キャリア周波数 = キャリア周波数導出( 電力, キャリア周波数テーブル );
				const キャリアステップ = キャリア周波数 / サンプリング周波数;
				出力[ i ] = 直流PWM( 電力 * ( 1 + キャリアステップ * 2 ), キャリア位相, サンプリング周波数 / キャリア周波数 );
				キャリア位相 = ( キャリア位相 + キャリアステップ ) % 1;

				this.波形グラフ && this.波形グラフ.値を記録( 出力[ i ] );
			}
		};

		function キャリア周波数導出( 電力, 設定 )
		{
			for( let i = 設定.length - 1; i >= 0; i -- )
			{
				const 項目 = 設定[ i ];
				if( 電力 > 項目[ 0 ] ) return 項目[ 1 ];
			}
			return 設定[ 0 ][ 1 ];
		}

		this.名称 = "PWM";
	};

	const PWM周波数倍率テーブル =
	{
		t1: [ [ 0, 1 ] ],
		t2: [ [ 0, 0.5 ], [ 0.018, 1 ], [ 0.982, 0.5 ] ],
		t3:
		[
			[ 0.00, 0.5 ], [ 0.02, 1 ], [ 0.04, 2 ], [ 0.06, 3 ],
			[ 0.94, 2 ], [ 0.96, 1 ], [ 0.98, 0.5 ]
		],
	};

	// 交流位相変調 //

	this.aph = function( 文脈 )
	{
		let 電源波位相 = 0;
		let 電源波周波数 = 50;
		
		let モニター位相 = 0;
		
		基底の型.call( this, 文脈 );

		this.波形生成 = function( 出力, 電力入力, サンプリング周波数 )
		{
			電源波周波数 = this.パラメータ && this.パラメータ[ 1 ] || 50;

			for( let i = 0; i < 出力.length; i ++ )
			{
				const 電力 = 電力入力[ i ];
				const sin = Math.sin( 電源波位相 * Math.PI * 2 );
				const ph = ( 電源波位相 * 2 ) % 1;
				出力[ i ] = ( 電力 > ph ? sin : 0 );
				電源波位相 = ( 電源波位相 + 電源波周波数 / サンプリング周波数 ) % 1;

				this.波形グラフ && this.波形グラフ.値を記録( 出力[ i ] );
			}
		};

		this.名称 = "交流位相制御";
	};

	// VVVF //

	this.vvvf = function( 文脈 )
	{
		const 更新レート = 100;

		let モジュレータ周波数;
		let モジュレータ位相 = 0;

		let 非同期キャリア周波数;
		let 非同期キャリア位相 = 0;

		let 同期キャリア周波数;
		let 同期キャリアサンプル数;
		let 同期キャリア位相;

		let 同期モードか = false;

		let upd = 0;

		基底の型.call( this, 文脈 );

		this.波形生成 = function( 出力バッファ, 電力入力バッファ, サンプリング周波数 )
		{
			for( let i = 0; i < 出力バッファ.length; i ++ )
			{
				const 電力 = 電力入力バッファ[ i ];

				if( upd -- == 0 )
				{
					upd = サンプリング周波数 / 更新レート;
					
					モジュレータ周波数 = 電力 * 80;

					if( モジュレータ周波数 >= 65 )
					{
						同期モードか = true;
						同期キャリアサンプル数 = 2;
						同期キャリア周波数 = モジュレータ周波数 * 同期キャリアサンプル数;
					}
					if( モジュレータ周波数 >= 60 )
					{
						同期モードか = true;
						同期キャリアサンプル数 = 12;
						同期キャリア周波数 = モジュレータ周波数 * 同期キャリアサンプル数;
					}
					else if( モジュレータ周波数 >= 50 )
					{
						同期モードか = false;
						非同期キャリア周波数 = 700 + ( モジュレータ周波数 - 50 ) * 1100 / 10;
					}
					else if( モジュレータ周波数 >= 20 )
					{
						同期モードか = false;
						非同期キャリア周波数 = 1050 - ( モジュレータ周波数 - 20 ) * 350 / 30;
					}
					else
					{
						同期モードか = false;
						非同期キャリア周波数 = 1050;
					}
				}

				{
					const モジュレータ = 電力 * Math.sin( モジュレータ位相 * Math.PI * 2 );

					出力バッファ[ i ] = 同期モードか ? 
						交流PWM( モジュレータ, ( モジュレータ位相 * 同期キャリアサンプル数 ) % 1, サンプリング周波数 / 同期キャリア周波数 ) :
						交流PWM( モジュレータ, 非同期キャリア位相, サンプリング周波数 / 非同期キャリア周波数 )
					;
				}

				モジュレータ位相 += モジュレータ周波数 / サンプリング周波数;
				if( モジュレータ位相 >= 1 )
				{
					モジュレータ位相 -= 1;
				}

				非同期キャリア位相 = ( 非同期キャリア位相 + 非同期キャリア周波数 / サンプリング周波数 ) % 1;


				this.波形グラフ && this.波形グラフ.値を記録( 出力バッファ[ i ] );
			}
		};

		const VVVFテーブル群 =
		{
			"e231-1000":
			[
				[ 0, 1050, 0 ],
				[ 20, 1050, - 350 / 30 ],
				[ 50, 0, 700, 1100 / 10 ],
				[ 60, 0, 1050 ],
			]
		};

		function キャリア計算( 電力, モジュレータ位相, 非同期キャリア位相, サンプリング周波数 )
		{
			let 非同期キャリア周波数 = 1050;
			let キャリア位相 = 非同期キャリア位相;
			const モジュレータ周波数 = 電力 * 80;

			return { キャリア位相: キャリア位相, キャリアステップ: 非同期キャリア周波数 / サンプリング周波数 };
		}

		this.名称 = "VVVF";
	};

	//  //

	function 交流PWM( モジュレータ, キャリア位相, サンプリングレート比 )
	{
		return モジュレータ >= 0 ?
			直流PWM( モジュレータ, キャリア位相, サンプリングレート比 ):
			- 直流PWM( - モジュレータ, キャリア位相, サンプリングレート比 )
		;
	}

	function 直流PWM( モジュレータ, キャリア位相, サンプリングレート比 )
	{
		const 三角波キャリア = キャリア位相 < 0.5 ? キャリア位相 * 2 : 2 - キャリア位相 * 2;
		const a = Math.max( 0, ( モジュレータ + 三角波キャリア ) - 1 ) * サンプリングレート比 / 2;
		return Math.min( 1, a );
	}

};

const グラフの型 = function( canvas, サンプリング周波数, 記録周期 )
{
	const framerate = 1;
	const context = canvas.getContext( "2d" );

	function clear()
	{
		context.fillStyle = "hsl( 225, 48%, 65% )";
		context.fillStyle = "hsl( 92, 43%, 56% )";
		context.fillRect( 0, 0, canvas.width, canvas.height );
	}

	function draw_grid( dx, dy )
	{
		clear();
		context.beginPath();
		context.lineWidth = 2;
		context.strokeStyle = "hsl( 0, 0%, 100% )";
		for( let i = 1; i < dy; i ++ )
		{
			const pos = canvas.height * i / dy;
			context.moveTo( 0, pos );
			context.lineTo( canvas.width, pos );
		}
		context.stroke();
	}

	const buffer = new Float32Array( サンプリング周波数 / 記録周期 );
	let bindex = 0;

	function update()
	{
		draw_grid( 4, 2 );
		const cy = canvas.height / 2;
		context.beginPath();
		context.moveTo( 0, cy );
		for( let i = 0; i < buffer.length; i ++ )
		{
			const y = cy - ( buffer[ i ] ) * cy;
			const x = i / buffer.length * canvas.width;
			context.lineTo( x + 0, y );
			context.lineTo( x + 1, y );
		}
		context.lineTo( canvas.width, cy );

		context.fillStyle = "hsl( 0, 0%, 100% )";
		//context.stroke();
		context.fill();
		requestAnimationFrame( update );
	}

	this.値を記録 = function( 値 )
	{
		buffer[ bindex ++ ] = 値;
		if( bindex >= buffer.length ) bindex = 0;
	};

	this.記録を同期 = function()
	{
		
	};

	update();
};

</script>
</body>
</html>