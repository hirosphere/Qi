<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
<title>VF905-2</title>
<style>
*
{
	margin: 0; padding: 0; color: #222;
	font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

html
{
}

body
{
}

.DIV1 { padding: 20px; }

button { margin-bottom: 10px; padding: 16px 24px; border-radius: 6px; }

#dummy { color: #fff; }

</style>
</head>
<body onload="window.main = new Main();">

<div class="DIV1">
	<button onclick='main.起動( "u1", [], "vvvf", [ "test1", 1050 ] )'>VVVF 1050</button>
	<button onclick='main.起動( "u1", [], "vvvf", [ "test1", 600 ] )'>VVVF 600</button>
	<button onclick='main.起動( "u1", [], "pwm", [ "t3", 300 ] )'>営団 03</button>
	<button onclick='main.起動( "u1", [], "pwm", [ "t1", 330 ] )'>営団 7000</button>
	<button onclick='main.起動( "u1", [], "pwm", [ "t1", 300 ] )'>国鉄201系</button>
	<button onclick='main.起動( "u1", [], "pwm", [ "t2", 300 ] )'>国鉄201系 2</button>
	<button onclick="main.起動( 'u1', [], 'aph', [ 1, 50 ] )">交流位相50Hz</button>
	<button onclick="main.起動( 'u1', [], 'aph', [ 1, 60 ] )">交流位相60Hz</button>
	<button onclick="main.起動( 'u1', [], 'aph', [ 1, 440 ] )">交流位相440Hz</button>
	<button onclick="main.運転装置.停止()">停止</button>
</div>

<div class="DIV1">
	<canvas id="analyser" width="512" height="320" style="margin-left: 20px; border: 12px solid hsl( 0, 0%, 20% ); width: 512px; height: 320px;"></canvas>
</div>

<div class="DIV1">
	音量 <input type="range" id="volume" value="30"; style="width: 300px;"/>
</div>

<p id="dummy"></p>

<script>

const version = "18.12.16 905 A";

const Main = function()
{
	const 文脈 = new AudioContext();

	const 音質フィルタ = 文脈.createBiquadFilter( { frequency: 2000, Q: 0.0 } );
	//音質フィルタ.connect( 文脈.destination );

	const 音量ノード = 文脈.createGain();
	{
		音量ノード.connect( 文脈.destination );
		const 音量レンジ = document.getElementById( "volume" );
		const 音量更新 = ()=> 音量ノード.gain.value = 音量レンジ.value / 100;
		音量レンジ.onchange = 音量更新;
		音量更新();
	}

	const 入力ノード = 文脈.createGain();
	{
		入力ノード.connect( 音量ノード );
		入力ノード.gain.value = 1;
	}

	const 運転装置 = this.運転装置 = new 運転装置の型( 文脈 );
	const 電力音源 = new 電力音源の型( 文脈, 運転装置, 入力ノード );
	const 波形グラフ = new グラフの型( document.getElementById( "analyser" ), 入力ノード, 文脈 );

	電力音源.モニター同期 = ()=> 波形グラフ.記録を更新();

	const dummy_el = document.getElementById( "dummy" );
	let dummy_ctr = 0;
	setInterval( ()=>{ dummy_el.textContent = ( new Date().getMilliseconds() ); }, 1000 / 15 );

	this.起動 = function( 運転パターン名, 運転パラメータ, 動力種名, 動力パラメータ )
	{
		運転装置.起動( 運転パターン名, 運転パラメータ );
		電力音源.種類を設定( 動力種名, 動力パラメータ );
	};
};

const 運転装置の型 = function( 文脈 )
{
	const モーター電力 = this.電力ノード = 文脈.createConstantSource();
	モーター電力.offset.value = 0;
	モーター電力.start();

	this.起動 = function( 運転パターン名, パラメータ )
	{
		文脈.resume();
		let cur = 文脈.currentTime;

		モーター電力.offset.cancelScheduledValues( cur );
		モーター電力.offset.setValueAtTime( 0, cur  );
		モーター電力.offset.linearRampToValueAtTime( 1, cur += 25  );
		モーター電力.offset.linearRampToValueAtTime( 1, cur += 3  );
		モーター電力.offset.linearRampToValueAtTime( 0, cur += 15  );
	};

	this.停止 = function()
	{
		let cur = 文脈.currentTime;

		モーター電力.offset.cancelScheduledValues( cur );
		モーター電力.offset.linearRampToValueAtTime( 0, cur += 0.20  );
	};

};

const 電力音源の型 = function( 文脈, 運転装置, 出力先ノード )
{
	let 音源子 = null;
	const 音源子群 = {};

	this.モニター同期;

	this.種類を設定 = function( 名称, パラメータ )
	{
		let temp = 音源子群[ 名称 ];
		if( temp == null )
		{
			const 型 = 電力音源子の型群[ 名称 ];
			if( 型 ) temp = 音源子群[ 名称 ] = new 型( 文脈 );
			else temp = 音源子群[ "def" ] = 音源子群[ "def" ] || new 電力音源子の型群.def( 文脈 );
		}
		
		if( 音源子 ) 音源子.切断();
		音源子 = temp;
		音源子.接続( 運転装置, 出力先ノード, パラメータ, this.モニター同期 );
	};
};

const 電力音源子の型群 = new function()
{
	// 基底型 //

	const 基底の型 = function( 文脈 )
	{
		const プロセッサ = 文脈.createScriptProcessor( 0, 1, 1 );
		let 制御器, モニター同期;

		プロセッサ.onaudioprocess = ( ev ) => this.波形生成
		(
			ev.outputBuffer.getChannelData( 0 ),
			ev.inputBuffer.getChannelData( 0 ),
			文脈.sampleRate
		);
		
		this.接続 = function( _制御器, 出力ノード, パラメータ, _モニター同期 )
		{
			制御器 = _制御器;
			this.パラメータ = パラメータ;
			モニター同期 = _モニター同期;

			プロセッサ.connect( 出力ノード );
			制御器.電力ノード.connect( プロセッサ );

			this.設定変更処理( this.パラメータ );
		};

		this.設定変更処理 = function( パラメータ )
		{
		};
		
		this.切断 = function()
		{
			プロセッサ.disconnect();
			制御器 && 制御器.電力ノード.disconnect( プロセッサ );
			制御器 = モニター同期 = null;
		};

		this.モニター同期 = function()
		{
			モニター同期 && モニター同期();
		};
		
	};
	
	// 直流PWM //

	const PWM基底の型 =
	this.def =
	this.pwm = function( 文脈 )
	{
		let キャリア位相 = 0;
		let モニター位相 = 0;
		let キャリア周波数テーブル = [ [ 0, 300 ] ];
		
		基底の型.call( this, 文脈 );

		this.設定変更処理 = function( パラメータ )
		{
			キャリア周波数テーブル = [ [ 0, 300 ] ];
			const 倍率テーブル = PWM周波数倍率テーブル[ パラメータ[ 0 ] ];
			const 基本周波数 = パラメータ[ 1 ] || 150;

			if( 倍率テーブル ) for( let i in 倍率テーブル )
			{
				const 項目 = 倍率テーブル[ i ];
				キャリア周波数テーブル[ i ] = [ 項目[ 0 ], 項目[ 1 ] * 基本周波数 ];
			}
		};

		this.波形生成 = function( 出力, 電力入力, サンプリング周波数 )
		{
			for( let i = 0; i < 出力.length; i ++ )
			{
				const 電力 = 電力入力[ i ];
				const キャリア周波数 = キャリア周波数導出( 電力, キャリア周波数テーブル );
				const キャリアステップ = キャリア周波数 / サンプリング周波数;
				出力[ i ] = 直流PWM( 電力 * ( 1 + キャリアステップ * 2 ), キャリア位相, サンプリング周波数 / キャリア周波数 );
				キャリア位相 = ( キャリア位相 + キャリアステップ ) % 1;

				if( ( モニター位相 += 50 / サンプリング周波数 ) >= 1 )  { モニター位相 -= 1;  this.モニター同期(); }
			}
		};

		function キャリア周波数導出( 電力, 設定 )
		{
			for( let i = 設定.length - 1; i >= 0; i -- )
			{
				const 項目 = 設定[ i ];
				if( 電力 > 項目[ 0 ] ) return 項目[ 1 ];
			}
			return 設定[ 0 ][ 1 ];
		}

		this.名称 = "PWM";
	};

	const PWM周波数倍率テーブル =
	{
		t1: [ [ 0, 1 ] ],
		t2: [ [ 0, 0.5 ], [ 0.018, 1 ], [ 0.982, 0.5 ] ],
		t3:
		[
			[ 0.00, 0.5 ], [ 0.02, 1 ], [ 0.04, 2 ], [ 0.06, 3 ],
			[ 0.94, 2 ], [ 0.96, 1 ], [ 0.98, 0.5 ]
		],
	};

	// 交流位相変調 //

	this.aph = function( 文脈 )
	{
		let 電源波位相 = 0;
		let 電源波周波数 = 50;
		
		let モニター位相 = 0;
		
		基底の型.call( this, 文脈 );

		this.波形生成 = function( 出力, 電力入力, サンプリング周波数 )
		{
			電源波周波数 = this.パラメータ && this.パラメータ[ 1 ] || 50;

			for( let i = 0; i < 出力.length; i ++ )
			{
				const 電力 = 電力入力[ i ];
				const sin = Math.sin( 電源波位相 * Math.PI * 2 );
				const ph = ( 電源波位相 * 2 ) % 1;
				出力[ i ] = ( 電力 > ph ? sin : 0 );
				電源波位相 = ( 電源波位相 + 電源波周波数 / サンプリング周波数 ) % 1;

				if( ( モニター位相 += 50 / サンプリング周波数 ) >= 1 )  { モニター位相 -= 1;  this.モニター同期(); }
			}
		};

		this.名称 = "交流位相制御";
	};

	// VVVF //

	this.vvvf = function( 文脈 )
	{
		let 非同期キャリア位相 = 0;
		let モジュレータ位相 = 0;

		let モニター位相 = 0;
		
		基底の型.call( this, 文脈 );

		this.波形生成 = function( 出力バッファ, 電力入力バッファ, サンプリング周波数 )
		{
			const 非同期キャリア周波数 = this.パラメータ[ 1 ] || 1050;

			for( let i = 0; i < 出力バッファ.length; i ++ )
			{
				const 電力 = 電力入力バッファ[ i ];
				const モジュレータ = 電力 * Math.sin( Math.PI * 2 * モジュレータ位相 );
				const モジュレータ周波数 = 電力 * 150;

				const キャリア周波数 = 非同期キャリア周波数;
				const キャリア位相 = キャリア位相導出( 電力, 非同期キャリア位相 );
				const キャリアステップ = キャリア周波数 / サンプリング周波数;

				//出力バッファ[ i ] = モジュレータ;
				出力バッファ[ i ] = 交流PWM( モジュレータ, キャリア位相, サンプリング周波数 / キャリア周波数 );
				
				モジュレータ位相 += モジュレータ周波数 / サンプリング周波数;
				if( モジュレータ位相 >= 1 )
				{
					モジュレータ位相 -= 1;
				}

				非同期キャリア位相 = ( 非同期キャリア位相 + キャリアステップ ) % 1;

				if( ( モニター位相 += 50 / サンプリング周波数 ) >= 1 )  { モニター位相 -= 1;  this.モニター同期(); }
			}
		};

		const キャリア位相導出 = function( 電力, 非同期キャリア位相 )
		{
			return 非同期キャリア位相;
		};

		this.名称 = "VVVF";
	};

	//  //

	function 交流PWM( モジュレータ, キャリア位相, サンプリングレート比 )
	{
		return モジュレータ >= 0 ?
			直流PWM( モジュレータ, キャリア位相, サンプリングレート比 ):
			- 直流PWM( - モジュレータ, キャリア位相, サンプリングレート比 )
		;
	}

	function 直流PWM( モジュレータ, キャリア位相, サンプリングレート比 )
	{
		const 三角波キャリア = キャリア位相 < 0.5 ? キャリア位相 * 2 : 2 - キャリア位相 * 2;
		const a = Math.max( 0, ( モジュレータ + 三角波キャリア ) - 1 ) * サンプリングレート比 / 2;
		return Math.min( 1, a );
	}

	const 正弦波テーブル群 =
	{
		1: []
	};

};

const グラフの型 = function( canvas, 入力, 音響文脈 )
{
	const framerate = 1;
	const analyser = 音響文脈.createAnalyser();
	
	入力.connect( analyser );

	const context = canvas.getContext( "2d" );

	function clear()
	{
		context.fillStyle = "hsl( 225, 48%, 65% )";
		context.fillRect( 0, 0, canvas.width, canvas.height );
	}

	function draw_grid( dx, dy )
	{
		clear();
		context.beginPath();
		context.lineWidth = 2;
		context.strokeStyle = "hsl( 0, 0%, 100% )";
		for( let i = 1; i < dy; i ++ )
		{
			const pos = canvas.height * i / dy;
			context.moveTo( 0, pos );
			context.lineTo( canvas.width, pos );
		}
		context.stroke();
	}

	const buffer = new Float32Array( Math.floor( 音響文脈.sampleRate / 50 ) );

	function update()
	{
		draw_grid( 4, 2 );
		const cy = canvas.height / 2;
		context.beginPath();
		context.moveTo( 0, cy );
		for( let i = 0; i < buffer.length; i ++ )
		{
			const y = cy - ( buffer[ i ] ) * cy;
			const x = i / buffer.length * canvas.width;
			context.lineTo( x + 0, y );
			context.lineTo( x + 1, y );
		}
		context.lineTo( canvas.width, cy );

		context.fillStyle = "hsl( 0, 0%, 100% )";
		//context.stroke();
		context.fill();
		requestAnimationFrame( update );
	}

	this.記録を更新 = function()
	{
		analyser.getFloatTimeDomainData( buffer );
		performance.now;
	};

	update();
};

</script>
</body>
</html>