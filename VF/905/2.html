<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
<title>VF905-2</title>
<style>
*
{
	margin: 0; padding: 0; color: #222;
	font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

html
{
}

body
{
}

.DIV1 { padding: 20px; }

button { padding: 16px 24px; border-radius: 6px; }

</style>
</head>
<body onload="window.main = new Main();">

<div class="DIV1">
	<button onclick="main.運転装置.起動( 't1' )">テスト 1</button>
	<button onclick="main.運転装置.起動( 't2' )">テスト 2</button>
	<button onclick="main.運転装置.停止()">停止</button>
</div>

<p id="dummy"></p>

<script>

const version = "18.12.16 905 A";

const Main = function()
{
	const 文脈 = new AudioContext();
	const filter = new BiquadFilterNode( 文脈, { frequency: 2000, Q: 0.0 } );
	//filter.connect( 文脈.destination );
	const 電力音源 = new 電力音源の型( 文脈, 文脈.destination, 0.2, "ei_03" );
	this.運転装置 = new 運転装置の型( 文脈, 電力音源 );

	const dummy_el = document.getElementById( "dummy" );
	let dummy_ctr = 0;
	setInterval( ()=>{ dummy_el.textContent = ( new Date().getMilliseconds() ); }, 1000 / 15 );
};

const 運転装置の型 = function( 文脈, 音源 )
{
	const モーター電力 = new ConstantSourceNode( 文脈, { offset: 0 } );
	モーター電力.connect( 音源.power_in );
	モーター電力.start();

	this.起動 = function( setting_name )
	{
		文脈.resume();
		let cur = 文脈.currentTime;

		モーター電力.offset.cancelAndHoldAtTime( cur );
		モーター電力.offset.setValueAtTime( 0, cur  );
		モーター電力.offset.linearRampToValueAtTime( 0.5, cur += 10  );
		cur += 3;
		モーター電力.offset.linearRampToValueAtTime( 0, cur += 2  );
	};

	this.停止 = function()
	{
		let cur = 文脈.currentTime;

		モーター電力.offset.cancelAndHoldAtTime( cur );
		モーター電力.offset.linearRampToValueAtTime( 0, cur += 0.20  );
	};

};

const 電力音源の型 = function( 文脈, dest, volume, type )
{
	const ga_out = new GainNode( 文脈, { gain: volume } );
	const sc_conv = 文脈.createScriptProcessor( 0, 1, 1 );
	const convs = {};

	sc_conv.connect( ga_out );
	
	ga_out.connect( dest );
	this.power_in = sc_conv;

	this.set_type = function( name )
	{
		const ctor = 電力変調器の型群[ name ] || 電力変調器の型群.ei_03;
		const conv = convs[ name ] = convs[ name ] || new ctor();
		sc_conv.onaudioprocess = ( ev ) => conv.audioprocess
		(
			ev.outputBuffer.getChannelData( 0 ),
			ev.inputBuffer.getChannelData( 0 ),
			文脈.sampleRate
		);
	};

	this.set_type( type );
};

const 電力変調器の型群 = {};

const 電力変調器の型 = function( キャリア周波数導出, 波形生成 )
{
	let キャリア位相 = 0;

	this.audioprocess = function( 出力, 電力入力, サンプリング周波数 )
	{
		for( let i = 0; i < 出力.length; i ++ )
		{
			const 電力 = 電力入力[ i ];
			const キャリア周波数 = キャリア周波数導出( 電力 );
			出力[ i ] = 波形生成( 電力, キャリア位相, サンプリング周波数 / キャリア周波数 );
			キャリア位相 = ( キャリア位相 += キャリア周波数 / サンプリング周波数 ) % 1;
		}
	};
};

電力変調器の型群.ei_03 = function()
{
	電力変調器の型.call( this, vtofs.eidan_pw, vtops.pw );	
};

const vtops =
{
	pw: function( mod, carr_phase, div )
	{
		const carr = carr_phase < 0.5 ? carr_phase * 2 : 2 - carr_phase * 2;
		const a = Math.max( 0, ( mod + carr ) - 1 ) * div / 2;
		return Math.min( 1, a );
	}
};

const vtofs =
{
	eidan_pw: function( pw )
	{
		const w = ( pw < 0.5 ? pw : 1 - pw );
		if( w < 0.020 ) return 150;
		if( w < 0.040 ) return 300;
		if( w < 0.060 ) return 600;
		return 900;
	},
	eidan_pw_: function( pw )
	{
		const w = ( pw < 0.5 ? pw : 1 - pw );
		if( w < 0.020 ) return 146.832 * 1;
		if( w < 0.040 ) return 146.832 * 2;
		if( w < 0.060 ) return 146.832 * 4;
		return 146.832 * 6;
	},
};

const mftocfs =
{
	e231k: function( mf )
	{
		return 1050;
	}
};

function eidan_freq( pw )
{
	const w = ( pw < 0.5 ? pw : 1 - pw );
	if( w < 0.020 ) return 150;
	if( w < 0.040 ) return 300;
	if( w < 0.060 ) return 600;
	return 900;
}


電力変調器の型群.vvvf_1 = function()
{
	const oversample = 1;
	let modu_phase = 0;
	let ac_phase = 0;
	let ac_freq = 300;

	this.audioprocess = function( out, inp, samplerate )
	{
		const osrate = samplerate * oversample;
		
		for( let i = 0; i < out.length; i ++ )
		{
			const voltage = inp[ i ];
			const modu_freq = voltage * 120;

			const modu_wave = voltage * get_sin( modu_phase );
			{
				modu_phase += modu_freq / samplerate;
				modu_phase %= 1;
				if( modu_phase >= 1 ) modu_phase -= 1;
			}

			{
				ac_phase += ac_freq / samplerate;
				ac_phase %= 1;
			}

			{
				const carr_phase = get_c_phase( voltage, ac_phase, modu_phase );
				out[ i ] = get_pulse( modu_wave, carr_phase );
			}
		}
	};

	function get_pulse( modu_wave, carr_phase )
	{
		const tri_phase = - ( carr_phase * 4 - 2 );
		const carr_wave =
		(
			tri_phase >= 0 ?
				( tri_phase > 1 ? 2 - tri_phase : tri_phase ) :
				( tri_phase > - 1 ? tri_phase : - 2 - tri_phase )
		);
		const a = modu_wave + carr_wave;
		if( a >= 1 ) return 1;
		if( a <= -1 ) return -1;
		return 0;
	};

	function get_c_phase( voltage, async_carr_phase, modu_phase )
	{
		if( voltage < 0.2 ) return async_carr_phase;
		if( voltage < 0.3 ) return ( modu_phase * 9 ) % 1;
		if( voltage < 0.5 ) return ( modu_phase * 5 ) % 1;
		if( voltage < 0.8 ) return ( modu_phase * 3 ) % 1;
		return modu_phase;
	};

	function freq_conv( voltage )
	{
		const mod = voltage * 150;
		if( mod < 7 )  return 300;
		if( mod < 11 )  return mod * 27;
		//if( mod < 15 )  return mod * 19;
		if( mod < 23 )  return mod * 13;
		if( mod < 33 )  return mod * 9;
		if( mod < 60 )  return mod * 5;
		if( mod < 80 )  return mod * 3;

		return mod;
	};
};

const vtop = function( voltage, plevel, sample_rate, freq )
{
	if( voltage >= 1 )
	{
		;
	}
	if( voltage <= -1 )
	{
		;
	};
	return 0;
};

const get_sin = ( phase )=>
{
	return Math.sin( phase * 2 * Math.PI );
};

</script>
</body>
</html>