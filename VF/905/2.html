<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
<title>VF905-2</title>
<style>
*
{
	margin: 0; padding: 0; color: #222;
	font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

html
{
}

body
{
}

.DIV1 { padding: 20px; }

button { padding: 16px 24px; border-radius: 6px; }

#dummy { color: #fff; }

</style>
</head>
<body onload="window.main = new Main();">

<div class="DIV1">
	<button onclick="main.起動( 'u1', [], 'pwm', [] )">国鉄201系</button>
	<button onclick="main.起動( 'u1', [], 'pwm', [] )">営団 7000</button>
	<button onclick="main.起動( 'u1', [], 'pwm', [] )">営団 03</button>
	<button onclick="main.起動( 'u1', [], 'aph', [ 50 ] )">交流位相50Hz</button>
	<button onclick="main.起動( 'u1', [], 'aph', [ 60 ] )">交流位相60Hz</button>
	<button onclick="main.起動( 'u1', [], 'vf2_1', [] )">VVVF 2レベル</button>
	<button onclick="main.運転装置.停止()">停止</button>
</div>

<div class="DIV1">
	<canvas id="analyser" width="512" height="320" style="margin-left: 20px; border: 0px solid #ccc; width: 512px; height: 320px;"></canvas>
</div>

<div class="DIV1">
	<input type="range" id="volume" value="30"; style="width: 300px;"/>
</div>

<p id="dummy"></p>

<script>

const version = "18.12.16 905 A";

const Main = function()
{
	const 文脈 = new AudioContext();

	const 音質フィルタ = 文脈.createBiquadFilter( { frequency: 2000, Q: 0.0 } );
	//音質フィルタ.connect( 文脈.destination );

	const 音量ノード = 文脈.createGain();
	{
		音量ノード.connect( 文脈.destination );
		const 音量レンジ = document.getElementById( "volume" );
		const 音量更新 = ()=> 音量ノード.gain.value = 音量レンジ.value / 100;
		音量レンジ.onchange = 音量更新;
		音量更新();
	}

	const 入力ノード = 文脈.createGain();
	{
		入力ノード.connect( 音量ノード );
		入力ノード.gain.value = 1;
	}

	const 運転装置 = this.運転装置 = new 運転装置の型( 文脈 );
	const 電力音源 = new 電力音源の型( 文脈, 運転装置, 入力ノード );
	const 波形グラフ = new グラフの型( document.getElementById( "analyser" ), 入力ノード, 文脈 );

	電力音源.モニター同期 = ()=> 波形グラフ.記録を更新();

	const dummy_el = document.getElementById( "dummy" );
	let dummy_ctr = 0;
	setInterval( ()=>{ dummy_el.textContent = ( new Date().getMilliseconds() ); }, 1000 / 15 );

	this.起動 = function( 運転パターン名, 運転パラメータ, 動力種名, 動力パラメータ )
	{
		運転装置.起動( 運転パターン名, 運転パラメータ );
		電力音源.種類を設定( 動力種名, 動力パラメータ );
	};
};

const 運転装置の型 = function( 文脈 )
{
	const モーター電力 = this.電力ノード = 文脈.createConstantSource();
	モーター電力.offset.value = 0;
	モーター電力.start();

	this.起動 = function( 運転パターン名, パラメータ )
	{
		文脈.resume();
		let cur = 文脈.currentTime;

		モーター電力.offset.cancelScheduledValues( cur );
		モーター電力.offset.setValueAtTime( 0, cur  );
		モーター電力.offset.linearRampToValueAtTime( 1, cur += 16  );
		モーター電力.offset.linearRampToValueAtTime( 1, cur += 3  );
		モーター電力.offset.linearRampToValueAtTime( 0, cur += 16  );
	};

	this.停止 = function()
	{
		let cur = 文脈.currentTime;

		モーター電力.offset.cancelScheduledValues( cur );
		モーター電力.offset.linearRampToValueAtTime( 0, cur += 0.20  );
	};

};

const 電力音源の型 = function( 文脈, 運転装置, 出力先ノード )
{
	let 音源子 = null;
	const 音源子群 = {};

	this.モニター同期;

	this.種類を設定 = function( 名称, パラメータ )
	{
		let temp = 音源子群[ 名称 ];
		if( temp == null )
		{
			const 型 = 電力音源子の型群[ 名称 ];
			if( 型 ) temp = 音源子群[ 名称 ] = new 型( 文脈 );
			else temp = 音源子群[ "def" ] = 音源子群[ "def" ] || new 電力音源子の型群.def( 文脈 );
		}
		
		if( 音源子 ) 音源子.切断();
		音源子 = temp;
		音源子.接続( 運転装置, 出力先ノード, パラメータ, this.モニター同期 );
	};
};

const 電力音源子の型群 = new function()
{
	// 基底型 //

	const 基底の型 = function( 文脈 )
	{
		const プロセッサ = 文脈.createScriptProcessor( 0, 1, 1 );
		let 制御器, モニター同期;

		プロセッサ.onaudioprocess = ( ev ) => this.波形生成
		(
			ev.outputBuffer.getChannelData( 0 ),
			ev.inputBuffer.getChannelData( 0 ),
			文脈.sampleRate
		);
		
		this.接続 = function( _制御器, 出力ノード, パラメータ, _モニター同期 )
		{
			console.log( "接続", this.名称 );
			制御器 = _制御器;
			モニター同期 = _モニター同期;
			プロセッサ.connect( 出力ノード );
			制御器.電力ノード.connect( プロセッサ );
		};
		
		this.切断 = function()
		{
			console.log( "切断", this.名称 );
			プロセッサ.disconnect();
			制御器 && 制御器.電力ノード.disconnect( プロセッサ );
			制御器 = モニター同期 = null;
		};

		this.モニター同期 = function()
		{
			モニター同期 && モニター同期();
		};
		
	};
	
	//  //
	
	function pwm()
	{
		;
	};
	
	function aph()
	{
		;
	};
	
	function vf()
	{
		;
	};

	//  //

	this.def =
	this.pwm = function( 文脈 )
	{
		let キャリア位相 = 0;
		let キャリア周波数 = 300;

		let モニター位相 = 0;
		
		基底の型.call( this, 文脈 );

		this.波形生成 = function( 出力, 電力入力, サンプリング周波数 )
		{
			for( let i = 0; i < 出力.length; i ++ )
			{
				const 電力 = 電力入力[ i ];
				const キャリアステップ = キャリア周波数 / サンプリング周波数;
				出力[ i ] = 直流PWM( 電力 * ( 1 + キャリアステップ ), キャリア位相, サンプリング周波数 / キャリア周波数 );
				キャリア位相 = ( キャリア位相 + キャリアステップ ) % 1;

				if( ( モニター位相 += 50 / サンプリング周波数 ) >= 1 )  { モニター位相 -= 1;  this.モニター同期(); }
			}
		};

		this.名称 = "PWM";
	};

	this.aph = function( 文脈 )
	{
		let 電源波位相 = 0;
		let 電源波周波数 = 50;
		
		let モニター位相 = 0;
		
		基底の型.call( this, 文脈 );

		this.波形生成 = function( 出力, 電力入力, サンプリング周波数 )
		{
			for( let i = 0; i < 出力.length; i ++ )
			{
				const 電力 = 電力入力[ i ];
				//出力[ i ] = 電力 * ( Math.random() * 2 - 1 );
				const sin = Math.sin( 電源波位相 * Math.PI * 2 );
				const ph = ( 電源波位相 * 2 ) % 1;
				出力[ i ] = ( 電力 > ph ? sin : 0 );
				電源波位相 = ( 電源波位相 + 電源波周波数 / サンプリング周波数 ) % 1;

				if( ( モニター位相 += 50 / サンプリング周波数 ) >= 1 )  { モニター位相 -= 1;  this.モニター同期(); }
			}
		};

		this.名称 = "デフォルト";
	};

	//  //

	function 直流PWM( モジュレータ, キャリア位相, サンプリングレート比 )
	{
		const 三角波キャリア = キャリア位相 < 0.5 ? キャリア位相 * 2 : 2 - キャリア位相 * 2;
		const a = Math.max( 0, ( モジュレータ + 三角波キャリア ) - 1 ) * サンプリングレート比 / 2;
		return Math.min( 1, a );
	}

};

const キャリア周波数導出関数群 =
{
	ec03: function( pw )
	{
		const w = ( pw < 0.5 ? pw : 1 - pw );
		if( w < 0.020 ) return 150;
		if( w < 0.040 ) return 300;
		if( w < 0.060 ) return 600;
		return 900;
	},
	
	aph50: function( pw )
	{
		return 50;
	},

	gto1: function( 電力, キャリア周波数 )
	{
		const freq = pw * 120;
		if( freq < 10 ) return 300;
		if( freq < 20 ) return freq * 15;
		if( freq < 30 ) return freq * 3;
		//if( freq < 20 ) return freq * 15;
		return freq;
	},
};

const 駆動波形生成関数群 =
{
	// 正弦波位相制御 //
	aph1: function( モジュレータ, キャリア位相, サンプリングレート比 )
	{
		const 正弦波 = Math.sin( キャリア位相 * Math.PI * 2 );
		const c2 = ( キャリア位相 * 2 ) % 1;
		return c2 < モジュレータ ? 正弦波 : 0;
	},

	// 交流PWM //
	vf2: function( モジュレータ, キャリア位相, サンプリングレート比 )
	{
		const 負極か = モジュレータ < 0;
		const 三角波キャリア = キャリア位相 < 0.5 ? キャリア位相 * 2 : 2 - キャリア位相 * 2;
		const a = Math.max( 0, ( Math.abs( モジュレータ ) + 三角波キャリア ) - 1 ) * サンプリングレート比 / 2;
		return  負極か ? - Math.min( 1, a ) : Math.min( 1, a );
	},

};

const グラフの型 = function( canvas, 入力, 音響文脈 )
{
	const framerate = 1;
	const analyser = 音響文脈.createAnalyser();
	
	入力.connect( analyser );

	const context = canvas.getContext( "2d" );

	function clear()
	{
		context.fillStyle = "hsl( 225, 50%, 60% )";
		context.fillRect( 0, 0, canvas.width, canvas.height );
	}

	function draw_grid( dx, dy )
	{
		clear();
		context.beginPath();
		context.lineWidth = 2;
		context.strokeStyle = "hsl( 0, 0%, 100% )";
		for( let i = 1; i < dy; i ++ )
		{
			const pos = canvas.height * i / dy;
			context.moveTo( 0, pos );
			context.lineTo( canvas.width, pos );
		}
		context.stroke();
	}

	const buffer = new Float32Array( Math.floor( 音響文脈.sampleRate / 50 ) );

	function update()
	{
		draw_grid( 4, 2 );
		const cy = canvas.height / 2;
		context.beginPath();
		context.moveTo( 0, cy );
		for( let i = 0; i < buffer.length; i ++ )
		{
			const y = cy - ( buffer[ i ] ) * cy;
			const x = i / buffer.length * canvas.width;
			context.lineTo( x + 1, y );
		}
		context.lineTo( canvas.width, cy );

		context.fillStyle = "hsl( 0, 0%, 100% )";
		//context.stroke();
		context.fill();
		requestAnimationFrame( update );
	}

	this.記録を更新 = function()
	{
		analyser.getFloatTimeDomainData( buffer );
		performance.now;
	};

	update();
};

</script>
</body>
</html>